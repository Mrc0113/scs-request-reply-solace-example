package com.itsjamilahmed.spring.scs.demo.fraudcheck.ApiErrorHandlingService;

import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.stream.binder.BinderHeaders;
import org.springframework.context.annotation.Bean;
import org.springframework.messaging.Message;
import org.springframework.messaging.support.MessageBuilder;

import java.util.function.Function;

@SpringBootApplication
public class ApiErrorHandlingServiceApplication {

	private static final Logger log = LoggerFactory.getLogger(ApiErrorHandlingServiceApplication.class);
	
	// Which message header keys store the PubSub+ broker inserted reply-to topic and correlation-IDs?
	static final String SOL_REPLYTO_DESTINATION_KEY = "solace_replyTo";
	static final String SOL_CORRELATION_ID_KEY = "solace_correlationId";

	// Which message header key stores the message timestamp?
	static final String SOL_MSG_TIMESTAMP_KEY = "timestamp";
	
	// Header keys to be used by the mediator service to store the values for pass-thru purposes to other services involved in the processing pipeline
	static final String MEDIATOR_REPLYTO_DESTINATION_KEY = "app_fraudCheckMediator_replyTo";
	static final String MEDIATOR_CORRELATION_ID_KEY = "app_fraudCheckMediator_correlationId";
	static final String MEDIATOR_MSG_TIMESTAMP_KEY = "app_fraudCheckMediator_timestamp";
	
	public static void main(String[] args) {
		SpringApplication.run(ApiErrorHandlingServiceApplication.class, args);
	}

	@Bean
	// Purpose: Generically receive error events that need to be routed back to the externally facing HTTP API
	//  * This service will receive an event that contains the error message as generated by any upstream service.
	//  * The event will also contain the reply-to topic and correlation ID to be used to route the response back to the open HTTP operation
	//  * that is awaiting a response via the PubSub+ Broker's Microgateway feature. 
	public Function<Message<String>, Message<String>> sendErrorResponse(){
		return input -> {
			
			String payload = input.getPayload();
			JSONObject jsonMessage;
			log.info("Received error message to process: " + input.getPayload());
			
			try {
				jsonMessage = (JSONObject) new JSONParser().parse(payload);
				jsonMessage.put("status", "error");
				
			} catch (ParseException e) {
				log.error("Did not receive a valid JSON formatted message for the error. " + e.toString());
				
				// Shouldn't really get here. The error message visible externally can be kept vague then.
				jsonMessage = new JSONObject();
				jsonMessage.put("errorMsg", "An unknown error occurred. Please retry the API call.");
			} 
			
			// May as well calculate the elapsed time between receiving the original request and this error event
			long errorMessageTimestampMs = Long.parseLong(input.getHeaders().getOrDefault(SOL_MSG_TIMESTAMP_KEY, "0").toString());
			long originalRequestTimestampMs = Long.parseLong(input.getHeaders().getOrDefault(MEDIATOR_MSG_TIMESTAMP_KEY, "0").toString());
			
			jsonMessage.put("elapsedTimeMs", errorMessageTimestampMs - originalRequestTimestampMs); 
			
			// There is an external HTTP API call expected to be waiting for this response, with the reply-to topic known as well for the TARGET_DESTINATION header.
			// If this is missing to trigger an exception, something has gone very wrong...
			Message<String> output = MessageBuilder.withPayload(jsonMessage.toString())
					.setHeader(SOL_CORRELATION_ID_KEY, input.getHeaders().getOrDefault(MEDIATOR_CORRELATION_ID_KEY, ""))
					.setHeader(BinderHeaders.TARGET_DESTINATION, input.getHeaders().getOrDefault(MEDIATOR_REPLYTO_DESTINATION_KEY, "error/fallback/topic/here").toString())
					.build();
			
			return output;
		};
	}
}
